
#'
#' Combine the output of compute_pf or compute_pf_for_fot into one dataframe
#'
#' @param pf_tbl the table output by `compute_pf` or `compute_pf_for_fot`
#' @param study_abbr string that corresponds with the study/studies of interest
#' @param visit_type_list the types of visits in the PF output; defaults to:
#'                        inpatient, outpatient, other_visit, all
#' @param domain_list a table with definitions for each domain (i.e. patientfacts::pf_domain_file)
#' @param time a logical indicating whether the analysis was conducted over time
#'
#' @return a dataframe containing information associated with all sites, domains,
#'         and visit types for the study listed in `study_abbr`
#'
#' @importFrom stringr str_remove
#' @importFrom tidyr pivot_longer
#'
combine_study_facts <- function(pf_tbl,
                                study_abbr,
                                domain_list,
                                time,
                                visit_type_list) {
  final_list <- list()

  pf_visits <-
    str_remove(names(pf_tbl),'(pf_)')

  names(pf_tbl) <- str_remove(names(pf_tbl), '(pf_)')

  for(i in 1:length(visit_type_list)) {

    possible_cols <-  domain_list %>%
      select(domain) %>% c()

    visit_type_pulled <-
      paste0(visit_type_list[[i]])

    pf_tbl_visittype <-
      pf_tbl[[visit_type_pulled]]

    tbl_cols <- pf_tbl_visittype %>% colnames()

    selected_cols <-
      intersect(possible_cols[[1]],
                tbl_cols)

    if(length(selected_cols) == 0){

      mutated_tbl <- NULL

    }else{

      if(!time){
        mutated_tbl <-
          pf_tbl_visittype %>%
          pivot_longer(cols=all_of(selected_cols),
                       names_to='domain',
                       values_to='var_val') %>%
          mutate(var_ever=case_when(!is.na(var_val)~1L,
                                    TRUE~0L)) %>%
          mutate(var_val=case_when(is.na(var_val) ~ 0,
                                   TRUE ~ var_val)) %>%
          mutate(study=study_abbr,
                 visit_type=visit_type_pulled)
      } else {mutated_tbl <- pf_tbl_visittype %>% mutate(study=study_abbr,
                                                         visit_type=visit_type_pulled)}

    }


    final_list[[i]] <- mutated_tbl

  }

  final_list_reduce <- reduce(.x=final_list,
                              .f=dplyr::union)
  final_list_reduce

}

#'
#' Compute median fact counts by visit & domain and by site, visit, & domain
#'
#' @param data_input input table generated by `loop_through_visits` and reduced with `combine_study_facts`
#' @param site_col the column in the data that holds site names
#' @param agegrp If you would like to stratify the results by age group, create a table or CSV file with the following
#'               columns and include it as the `agegrp` function parameter:
#' - `min_age`: the minimum age for the group (i.e. 10)
#' - `max_age`: the maximum age for the group (i.e. 20)
#' - `group`: a string label for the group (i.e. "10-20", "Young Adult", etc.)
#'
#' @return dataframe that contains the total median number of facts for that visit & domain
#'         as well as the median number of facts for the site, visit, & domain for each
#'         study. The medians are compute both with patients who do not have evidence of the domain
#'         (with 0s) and without those patients (without 0s)
#'
#' @importFrom stats median
#'
compute_pf_medians <- function(data_input,
                               site_col,
                               agegrp=NULL
                               #codeset=NULL
) {


  data_input_cols <- data_input %>% colnames()

  if('cohort' %in% data_input_cols) {
    data_input_grp <-
      data_input %>% group_by(cohort)
  } else {data_input_grp <- data_input}

  if(is.data.frame(agegrp)) {data_input_grp <- data_input_grp %>% group_by(age_grp,.add=TRUE) %>%
    mutate(age_grp = ifelse(is.na(age_grp), 'None', age_grp))}
  # if(is.data.frame(codeset)) {data_input_grp <- data_input_grp %>% group_by(flag,.add=TRUE) %>%
  #   mutate(flag = ifelse(is.na(flag), 'None', flag))}

  site_distance_medians_tbl <-
    data_input_grp %>%
    group_by(study,
             visit_type,
             domain,
             .add=TRUE) %>%
    mutate(median_all_with0s=median(var_val),
           median_all_without0s=median(var_val[var_val!=0])) %>%
    ungroup()

  site_distance_final <-
    data_input_grp %>%
    left_join(site_distance_medians_tbl) %>%
    group_by(study,
             !!sym(site_col),
             visit_type,
             domain,
             median_all_with0s,
             median_all_without0s,
             .add=TRUE) %>%
    summarise(n_tot=n(),
              n_w_fact=sum(var_ever),
              median_site_with0s=median(var_val),
              median_site_without0s=median(var_val[var_val!=0])) %>% ungroup() #%>%
  #mutate(prop_all_w_fact=round(n_w_fact/n_tot,3))

  site_distance_final <-
    site_distance_final %>% replace(is.na(.), 0) %>%
    mutate(across(everything(), ~ replace(.x, is.nan(.x), 0)))


  site_distance_final

}


#'
#' Compute distance from mean to identify patients with an anomalous number of facts per year
#' of follow up
#'
#' @param data_input input table generated by `loop_through_visits` and reduced with `combine_study_facts`
#' @param site_col the column in the data that holds site names
#' @param n_sd the number of standard deviations that should be used as a threshold to
#'             identify an outlier
#' @param agegrp If you would like to stratify the results by age group, create a table or CSV file with the following
#'               columns and include it as the `agegrp` function parameter:
#' - `min_age`: the minimum age for the group (i.e. 10)
#' - `max_age`: the maximum age for the group (i.e. 20)
#' - `group`: a string label for the group (i.e. "10-20", "Young Adult", etc.)
#'
#' @return a dataframe that summarises the number of patients with fact counts that fall +/- `n_sd` away from
#'         the mean both at visit_type + domain and site, visit_type, + domain levels
#'
#'         contains columns: person_id, start_date, end_date, fu, site, domain, var_val, var_ever, study,
#'                           visit_type, n_fact, zscore_fact, outlier_fact, prop_outlier_fact, n_site_fact,
#'                           zscore_site_fact, outlier_site_fact, prop_outlier_site_fact
#'
#' @importFrom stats sd
#'
compute_dist_mean_pf <- function(data_input,
                                 site_col,
                                 n_sd = 2,
                                 agegrp = NULL
                                 #codeset = NULL
) {

  if(is.data.frame(agegrp)) {data_input <- data_input %>% group_by(age_grp,.add=TRUE) %>%
    mutate(age_grp = ifelse(is.na(age_grp), 'None', age_grp))}
  # if(is.data.frame(codeset)) {data_input <- data_input %>% group_by(flag,.add=TRUE) %>%
  #   mutate(flag = ifelse(is.na(flag), 'None', flag))}

  site_dist_means_tot <-
    data_input %>%
    group_by(study,
             !!sym(site_col),
             visit_type,
             domain,
             .add=TRUE) %>%
    summarise(n_tot=n(),
              mean_tot=mean(var_val),
              sd_tot=sd(var_val),
              zscore_tot = ((var_val - mean_tot) / sd_tot),
              abs_z = abs(zscore_tot),
              outlier = case_when(abs_z > n_sd ~ 1L,
                                  TRUE ~ 0L),
              outlier_tot = sum(outlier),
              prop_outlier_tot = round(outlier_tot / n_tot, 3)) %>%
    select(group_vars(.), n_tot, outlier_tot, mean_tot, sd_tot, prop_outlier_tot) %>%
    ungroup() %>% distinct()


  site_dist_means_fact <-
    data_input %>%
    filter(var_ever == 1) %>%
    group_by(study,
             !!sym(site_col),
             visit_type,
             domain,
             .add=TRUE) %>%
    summarise(n_w_fact=n(),
              mean_fact=mean(var_val),
              sd_fact=sd(var_val),
              zscore_fact = ((var_val - mean_fact) / sd_fact),
              abs_z = abs(zscore_fact),
              outlier = case_when(abs_z > n_sd ~ 1L,
                                  TRUE ~ 0L),
              outlier_fact = sum(outlier),
              prop_outlier_fact = round(outlier_fact / n_w_fact, 3)) %>%
    ungroup() %>%
    select(-c(outlier, abs_z, zscore_fact)) %>% distinct() %>%
    left_join(site_dist_means_tot)

  site_dist_means_final <-
    site_dist_means_fact %>% replace(is.na(.), 0)

  site_dist_means_final
}
